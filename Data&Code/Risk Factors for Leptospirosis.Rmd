---
title: "Risk Factors for Leptospirosis"
author: "Yile Shi"
date: '2022-07-12'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
Sys.setlocale("LC_ALL", "UK")
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(lme4)
library(car)
library(DHARMa)
library(pROC)
library(caret)
```

## Exploratory Data Analysis (EDA)

```{r}
# load Leptospirosis data
lep_dat <- readxl::read_excel("Leptospirosis data for MSc SWDS.xlsx")
# fix erroneous data
lep_dat$relationshiphh[lep_dat$relationshiphh == "Son Lnlaw"] = "Son In Law"
lep_dat$gender[lep_dat$relationshiphh %in% c("Wife", "Daughter")] = "Female"
lep_dat$gender[lep_dat$relationshiphh == "Son"] = "Male"
lep_dat$village[lep_dat$village == "village 5"] = "Village 5"
# drop duplicated observations in the dataset
lep_dat <- unique(lep_dat)
```

Then, we have a look at the number of missing values in each column and the corresponding proportion.

```{r}
miss_mat <- matrix(nrow = ncol(lep_dat), ncol = 2)
# the number of missing values in each column
miss_mat[, 1] <- apply(lep_dat, 2, function(x) length(x[is.na(x)]))
# the proportion of missing values in each column
miss_mat[, 2] <- round(miss_mat[, 1] / nrow(lep_dat), 4)
row.names(miss_mat) <- colnames(lep_dat)
colnames(miss_mat) <- c("Number", "Proportion")
# keep the columns with missing values
miss_mat <- miss_mat[which(miss_mat[, 1] > 0), ]
# display the matrix in decreasing order
miss_mat[order(miss_mat[, 1], decreasing = TRUE),]
```

Most columns have no missing data. From the matrix above, we can find that `age`, `gender` and `landuse` have missing values less than 1%. Thus, we can drop these rows as we do not loss much information of the original dataset.

```{r}
# drop rows with missing values in age, gender and landuse
lep_dat <- lep_dat %>% drop_na(c(landuse, gender, age))
```

As for `occupation`, `disthosp`, `livestk_home` and `location`, which contain a large amount of missing values, we cannot drop the corresponding observations directly. Instead, we explore the distribution of each variable and determine a proper way to deal with them.

### `location`

According to the data description, `location` is the anonymised location of area where sampling was done, from 1 to 19. A possible way to deal with the missing data in this column is using the `village` variable, with no missing value, in the same row to determine the corresponding location, as each village belongs to a location with no overlap. 
However, looking at the dataset and referring to Google Maps, we decide to use `constituency` to represent the geographical feature of each sample, instead of `village` and `location`, based on the following reasons:
\begin{itemize}
  \item `constituency` has no missing value
  \item `constituency` contains information in `village` and `location`
  \item `constituency` has fewer categories but more significant geographical differences
\end{itemize}

From the map, we can observe a potential order in `constituency` based on the distance to Tana River and the terrain. Further details will be discussed in the feature transformation step.

### `livestk_home`

`livestk_home` is a binary variable indicating whether or not livestock is kept in the household of sampled person. The work of Cook et al (2016) found that the exposure to livestocks could be an important risk factor for Leptospirosis and we might also expect the significant contribution to Leptospirosis diagnosis of this variable. However, from the histogram below, we observe a significant imbalance in this column as most families have livestocks at home. In this case, we won't include this variable in our further analysis as the imbalance probably leads to insignificant results of this variable.

```{r, fig.width = 9, fig.height = 4}
ggplot(data = lep_dat, aes(x = factor(livestk_home)))+
  geom_bar(stat = "count", width = 0.15, color="darkblue", fill="lightblue") +
  labs(x ="livestk_home")
```

### `disthosp`

`disthosp` is the Euclidean distance from the sampled person's household to local hospital. Here, we assume that people from the same village go to the same and unique hospital. Thus, we can use the mean distance to the local hospital of each village to impute the missing values in this column.

Note that `disthosp` in village 12, 13 and 23 are completely missing. We cannot calculate the mean distance to the local hospital and further fail to impute the missing data. In this case, we decide to drop the corresponding rows.

```{r}
# compute the mean distance of each village
dist_mean <- lep_dat %>%
  select(disthosp, village) %>%
  drop_na() %>%
  group_by(village) %>%
  summarize(dist = mean(disthosp))

# impute missing values
for (i in dist_mean$village){
  idx <- which(lep_dat$village == i & is.na(lep_dat$disthosp))
  lep_dat$disthosp[idx] <- dist_mean$dist[which(dist_mean$village == i)]
}
```

### `occupation`

The job of a person could have influence on the prevalence of Leptospirosis. Specifically, Cook et al (2016) pointed out that people whose working places are closer to water or animals are more likely to suffer from Leptospirosis. However, in our dataset, the column for the occupation of sampled person contains over 1/3 missing data. Unlike `location`, whose information is included in `constituency`, `occupation`has no other column to use instead and omission of missing values could result in a huge loss of information. Thus, we consider using other columns including `age`, `gender` and `landuse` to impute the variable. A general imputation idea is using the mode in some specific stratification.

It is a common and reasonable assumption that people less than 18 years old are most likely to be students. Therefore, we impute the occupation of people below 18 years old with "Student".

```{r, fig.width = 8, fig.height = 3}
# histogram for occupation of people below 18
ggplot(data = lep_dat %>% filter(age < 18) %>% drop_na(occupation), 
       aes(x = factor(occupation)))+
  geom_bar(stat = "count", width = 0.25, color="darkblue", fill="lightblue") +
  labs(x ="occupation (age < 18)")
```

```{r, fig.width = 8, fig.height = 3}
ggplot(data = lep_dat %>% filter(age >= 18) %>% drop_na(occupation), 
       aes(x = factor(occupation)))+
  geom_bar(stat = "count", width = 0.5, color="darkblue", fill="lightblue") +
  labs(x ="occupation (age >= 18)")
```

```{r}
# indices of people below 18 with unrecorded occupation 
idx <- which(lep_dat$age < 18 & is.na(lep_dat$occupation))
# impute with "Student"
lep_dat$occupation[idx] = "Student"
```

For people at least 18 years old, their occupations could be correlated with various variables including `landuse`, `constituency` and `gender`, which makes it tricky to impute the missing values in `occupation`. Before applying any imputation methods, we hold `age` >= 18 and plot the corresponding conditional distributions to have a clear insight of this column. 

"Farmer" becomes the most popular job among sample adults whose land use is "riverine" and "Pastoralist" comes to the second. Since the number of this category is small (47 observations), we do not explore further in different `constituency` groups.

Holding `landuse` = "irrigation", we observe that over 90% adults have their occupations as "Farmer". To be more specific, we condition on `constituency` and plot the distribution in each group. As a result, most people come from "Tana North" and almost all of them have the job as "Farmer". Although "Farmer" is still the most popular job in the group of "Tana River", the proportion of people with a job as "Pastoralist" slightly increases.

```{r, fig.width = 8, fig.height = 9}
# landuse = riverine
p1 <- ggplot(data = lep_dat %>% 
               filter(age >= 18 & landuse == "riverine") %>% 
               drop_na(occupation), 
             aes(x = factor(occupation)))+
  geom_bar(stat = "count", width = 0.15, color="darkblue", fill="lightblue") +
  labs(x ="riverine")

# landuse = irrigation
p2 <- ggplot(data = lep_dat %>% 
               filter(age >= 18 & landuse == "irrigation") %>%
               drop_na(occupation), 
             aes(x = factor(occupation)))+
  geom_bar(stat = "count", width = 0.4, color="darkblue", fill="lightblue") +
  labs(x ="irrigation")

# landuse = pastoral
p3 <- ggplot(data = lep_dat %>% 
               filter(age >= 18 & landuse == "pastoral") %>%
               drop_na(occupation), 
             aes(x = factor(occupation)))+
  geom_bar(stat = "count", width = 0.4, color="darkblue", fill="lightblue") +
  labs(x ="pastoral")

grid.arrange(p1, p2, p3)

```

The case of group "pastoral" is more complex. It seems that "Pastoralist" plays a much more important role than any other categories in this group. However, we notice that the second most popular job is "Housewife". In this case, we suspect that there probably exists different distributions between genders. As shown in the plots below, "Pastoralist" is the most popular job in male group, with a much higher frequency than any other categories. In female group, "Pastoralist" still has the most observations, but "Housewife" takes larger proportion, which is significantly different from the general case. 

Moreover, we take the influence of `constituency` into consideration. Due to the great amount of "Pastoralist" in the male group, we do not observe significant difference among male individuals in different constituencies and "Pastoralist"

```{r, fig.width = 8, fig.height = 10}
# landuse = pastoral + constituency = Tana North + gender = Male
p1 <- ggplot(data = lep_dat %>% 
               filter(age >= 18 & 
                        landuse == "pastoral" & 
                        gender == "Male" & 
                        constituency == "Tana North") %>% 
               drop_na(occupation), 
             aes(x = factor(occupation)))+
  geom_bar(stat = "count", width = 0.2, color="darkblue", fill="lightblue") +
  labs(x ="Tana North, Male")

# landuse = pastoral + constituency = Tana North + gender = Female
p2 <- ggplot(data = lep_dat %>% 
               filter(age >= 18 & 
                        landuse == "pastoral" & 
                        gender == "Female" &
                        constituency == "Tana North") %>%
               drop_na(occupation), 
             aes(x = factor(occupation)))+
  geom_bar(stat = "count", width = 0.08, color="darkblue", fill="lightblue") +
  labs(x ="Tana North, Female")

# landuse = pastoral + constituency = Tana River + gender = Male
p3 <- ggplot(data = lep_dat %>% 
               filter(age >= 18 & 
                        landuse == "pastoral" & 
                        gender == "Male" &
                        constituency == "Tana River") %>%
               drop_na(occupation), 
             aes(x = factor(occupation)))+
  geom_bar(stat = "count", width = 0.2, color="darkblue", fill="lightblue") +
  labs(x ="Tana River, Male")

# landuse = pastoral + constituency = Tana North + gender = Female
p4 <- ggplot(data = lep_dat %>% 
               filter(age >= 18 & 
                        landuse == "pastoral" & 
                        gender == "Female" &
                        constituency == "Tana River") %>%
               drop_na(occupation), 
             aes(x = factor(occupation)))+
  geom_bar(stat = "count", width = 0.08, color="darkblue", fill="lightblue") +
  labs(x ="Tana River, Female")

# landuse = pastoral + constituency = Ijara + gender = Male
p5 <- ggplot(data = lep_dat %>% 
               filter(age >= 18 & 
                        landuse == "pastoral" & 
                        gender == "Male" &
                        constituency == "Ijara") %>%
               drop_na(occupation), 
             aes(x = factor(occupation)))+
  geom_bar(stat = "count", width = 0.15, color="darkblue", fill="lightblue") +
  labs(x ="Ijara, Male")

# landuse = pastoral + constituency = Ijara + gender = Female
p6 <- ggplot(data = lep_dat %>% 
               filter(age >= 18 & 
                        landuse == "pastoral" & 
                        gender == "Female" &
                        constituency == "Ijara") %>%
               drop_na(occupation), 
             aes(x = factor(occupation)))+
  geom_bar(stat = "count", width = 0.2, color="darkblue", fill="lightblue") +
  labs(x ="Ijara, Female")

# landuse = pastoral + constituency = Sangailu + gender = Male
p7 <- ggplot(data = lep_dat %>% 
               filter(age >= 18 & 
                        landuse == "pastoral" & 
                        gender == "Male" &
                        constituency == "Sangailu") %>%
               drop_na(occupation), 
             aes(x = factor(occupation)))+
  geom_bar(stat = "count", width = 0.3, color="darkblue", fill="lightblue") +
  labs(x ="Sangailu, Male")

# landuse = pastoral + constituency = Sangailu + gender = Female
p8 <- ggplot(data = lep_dat %>% 
               filter(age >= 18 & 
                        landuse == "pastoral" & 
                        gender == "Female" &
                        constituency == "Sangailu") %>%
               drop_na(occupation), 
             aes(x = factor(occupation)))+
  geom_bar(stat = "count", width = 0.2, color="darkblue", fill="lightblue") +
  labs(x ="Sangailu, Female")

grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, ncol = 2)

```

### Feature Selection

Here, we drop the observations with missing values in `occupation` and `disthosp`
directly from the dataset. After then, we combine some categories in `occupation` and `hhoccup` to ensure that each category contains sufficient observations. We make boxplots and barplots to explore if the feature affects `result` significantly:
```{r}
# drop NAs in `occupation` and `disthosp`
lep_narm <- lep_dat %>%
  drop_na(occupation, disthosp, location) %>%
  filter(disthosp < 100)
```

```{r, fig.width = 8}
occ_count <- lep_narm %>% select(occupation, result) %>%
  group_by(occupation) %>%
  count(occupation)

occ_count[order(occ_count$n, decreasing = T),]

ggplot(lep_narm, aes(x = occupation, fill = result)) + 
  geom_bar(width = 0.35) + 
  scale_fill_manual(values = c("lightblue", "darkblue")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x ="occupation")                  
```

```{r}
hhocc_count <- lep_narm %>% select(hhoccup, result) %>%
  group_by(hhoccup) %>%
  count(hhoccup)

hhocc_count[order(hhocc_count$n, decreasing = T),]

ggplot(lep_narm, aes(x = hhoccup, fill = result)) + 
  geom_bar(width = 0.35) + 
  scale_fill_manual(values = c("lightblue", "darkblue")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x ="hhoccup")                  
```

```{r}
lep_narm <- lep_narm %>% 
  filter(occupation %in% occ_count$occupation[occ_count$n > 20])
```

```{r}

lep_narm <- lep_narm %>% 
  filter(hhoccup %in% hhocc_count$hhoccup[hhocc_count$n > 20])

lep_narm$occupation[lep_narm$occupation %in% 
                        c("Herdsman", "Pastoralist")] = "Pastoral"
```


```{r}
# combine categories in `occupation`
lep_narm$occupation[lep_narm$occupation %in% 
                        c("Farmer", "Crop Farming")] = "Farming"
lep_narm$occupation[lep_narm$occupation %in% 
                        c("Herdsman", "Pastoralist")] = "Pastoral"

# combine categories in `hhoccup`
lep_narm$hhoccup[lep_narm$hhoccup %in% 
                        c("Farmer", "Crop Farming")] = "Farming"
lep_narm$hhoccup[lep_narm$hhoccup %in% 
                        c("Herdsman", "Pastoralist")] = "Pastoral"
```

```{r, fig.height = 10, fig.width = 8}
# boxplots for continuous variables
# age
p1 <- ggplot(lep_narm, aes(x = result, y = age)) + 
  geom_boxplot(width = 0.25, color = "darkblue", fill = "lightblue") + 
  labs(x = "result")

# altitude
p2 <- ggplot(lep_narm, aes(x = result, y = altitude)) + 
  geom_boxplot(width = 0.25, color = "darkblue", fill = "lightblue") + 
  labs(x = "result")

# nmales
p3 <- ggplot(lep_narm, aes(x = result, y = nmales)) + 
  geom_boxplot(width = 0.25, color = "darkblue", fill = "lightblue") + 
  labs(x = "result")

# nfemales
p4 <- ggplot(lep_narm, aes(x = result, y = nfemales)) + 
  geom_boxplot(width = 0.25, color = "darkblue", fill = "lightblue") + 
  labs(x = "result")

# famsize
p5 <- ggplot(lep_narm, aes(x = result, y = famsize)) + 
  geom_boxplot(width = 0.25, color = "darkblue", fill = "lightblue") + 
  labs(x = "result")

# disthosp
p6 <- ggplot(lep_narm, aes(x = result, y = disthosp)) + 
  geom_boxplot(width = 0.25, color = "darkblue", fill = "lightblue") + 
  labs(x = "result")

# display plots
grid.arrange(p1, p2, p3, p4, p5, p6, ncol = 2)
```

```{r, fig.height = 5, fig.width = 8}
# stacked barplots for discrete factors
# gender
p1 <- ggplot(lep_narm, aes(x = gender, fill = result)) + 
  geom_bar(width = 0.2) + 
  scale_fill_manual(values = c("lightblue", "darkblue")) +
  labs(x ="gender")

# occupation
p2 <- ggplot(lep_narm, aes(x = occupation, fill = result)) + 
  geom_bar(width = 0.35) + 
  scale_fill_manual(values = c("lightblue", "darkblue")) +
  labs(x ="occupation")

# landuse
p3 <- ggplot(lep_narm, aes(x = landuse, fill = result)) + 
  geom_bar(width = 0.3) + 
  scale_fill_manual(values = c("lightblue", "darkblue")) +
  labs(x ="landuse")

# hhoccup
p4 <- ggplot(lep_narm, aes(x = hhoccup, fill = result)) + 
  geom_bar(width = 0.3) + 
  scale_fill_manual(values = c("lightblue", "darkblue")) +
  labs(x ="hhoccup")

p5 <- ggplot(lep_narm, aes(x = hhgender, fill = result)) + 
  geom_bar(width = 0.3) + 
  scale_fill_manual(values = c("lightblue", "darkblue")) +
  labs(x ="hhgender")

# display plots
grid.arrange(p1, p2, p3, p4, p5, ncol = 2)
```

```{r, fig.height = 8, fig.width = 8}
# village
p1 <- ggplot(lep_narm, aes(x = village, fill = result)) + 
  geom_bar() + 
  scale_fill_manual(values = c("lightblue", "darkblue")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x ="village")

# location
p2 <- ggplot(lep_narm, aes(x = location, fill = result)) + 
  geom_bar() + 
  scale_fill_manual(values = c("lightblue", "darkblue")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x ="location")

# constituency
p3 <- ggplot(lep_narm, aes(x = constituency, fill = result)) + 
  geom_bar(width = 0.2) + 
  scale_fill_manual(values = c("lightblue", "darkblue")) +
  labs(x ="constituency")

# display plots
grid.arrange(p1, p2, p3)
```

## Inplementation

Model: Linear Mixed Model

```{r}
# factorize the response, i.e. result
lep_narm$result <- factor(lep_narm$result)
# initial GLM for binomial response over feature candidates
glm <- glm(result ~ gender + age + occupation + landuse + altitude +
             famsize + hhoccup + disthosp, 
           data = lep_narm,
           family = binomial(link = "logit"))

# identify which columns are significant based on model summary
summary(glm)
# significance check using step()
step(glm, test = "Chisq")
```

```{r}
# GLM with selected variables
glm_selected <- glm(result ~ gender + landuse + hhoccup, 
                  data = lep_narm,
                  family = binomial(link = "logit"))

# model summary
summary(glm_selected)
# Chi-square test for variables
step(glm_selected, test = "Chisq")
```


```{r}
# glmer with random effect of constituency on intercept
glmer_v_1 <- glmer(result ~ gender + landuse + hhoccup + (1 | village), 
                   data = lep_narm,
                   family = binomial(link = "logit"))

# ANOVA
anova(glmer_v_1, glm_selected)
```
```{r}
# constituency model considering random slopes
# gender
glmer_v_2 <- glmer(result ~ gender + landuse + hhoccup + 
                     (1 + gender| village), 
                 data = lep_narm,
                 family = binomial(link = "logit"))

# landuse
glmer_v_3 <- glmer(result ~ gender + landuse + hhoccup + 
                     (1 + landuse| village), 
                 data = lep_narm,
                 family = binomial(link = "logit"))

# hhoccup
glmer_v_4 <- glmer(result ~ gender + landuse + hhoccup + 
                     (1 + hhoccup| village), 
                 data = lep_narm,
                 family = binomial(link = "logit"))

# ANOVA
anova(glmer_v_1, glmer_v_2, glmer_v_3, glmer_v_4)
```

```{r}
# glmer with random effect of location on intercept
glmer_l <- glmer(result ~ gender + landuse + hhoccup + (1 | location), 
                 data = lep_narm,
                 family = binomial(link = "logit"))

# AIC
AIC(glmer_v_1, glmer_l)
```

```{r}
# village model summary
summary(glmer_v_1)
```

```{r}
# location model summary
summary(glmer_l)
```

```{r}
vif(glmer_v_1)
```


```{r, fig.width = 8}
# use plot function in DHARMa package for model diagnosis
sim <- simulateResiduals(glmer_v_1, 1000)
plot(sim)
```

```{r, warning = FALSE, fig.width = 8}
# diagnosis plots for each dependent variable
plot(sim, form = lep_narm$gender)
plot(sim, form = lep_narm$landuse)
plot(sim, form = lep_narm$hhoccup)
```
```{r, warning = FALSE, fig.width = 8}
# diagnosis plot for some features unused in the model
plot(sim, form = lep_narm$age)
plot(sim, form = lep_narm$famsize)
plot(sim, form = lep_narm$disthosp)
plot(sim, form = lep_narm$occupation)
```

```{r, fig.width = 8}
# model predictions
# glmer - village
pred_v_1 <- predict(glmer_v_1, newdata = lep_narm, type = "response")
# glmer - location
pred_l <- predict(glmer_l, newdata = lep_narm, type = "response")

# ROC and AUC of models
# glmer - village
roc(lep_narm$result, pred_v_1, plot = TRUE, col = "red")
# glmer - location
roc(lep_narm$result, pred_l, plot = TRUE, add = TRUE, col = "blue")
# glm
roc(lep_narm$result, glm_selected$fitted.values, plot = TRUE, 
    add = TRUE, col = "green")
# legends
legend("topleft", legend = c("glmer-village", "glmer-location", "glm"),
       col = c("red", "blue", "green"), lty = c(1, 1, 1), lwd = c(2, 2, 2))
```

```{r, include = FALSE}
# cv for mean AUC
# glmer - village
# set random seed
set.seed(1)
# set number of folds and create folds
num_fold <- 10
folds <- createFolds(lep_narm$result, k = num_fold)

# generate training sets and fit regression models
lglep_cv <- NULL
for (i in (1 : num_fold)){
  train_idx <- setdiff(1 : nrow(lep_narm), folds[[i]])
  lglep_cv[[i]] <- glmer(result ~ gender + landuse + hhoccup + (1 | village), 
                         family = "binomial"(link = "logit"), 
                         data = lep_narm, subset = train_idx)
}

# initialize vectors to store predictive values and AUC
pred_v_cv <- NULL
auc_cv <- numeric(num_fold)

# predict and compute AUC of each model 
for (j in (1 : num_fold)){
  # test set
  test_idx <- folds[[j]] 
  # model prediction
  pred_v_cv[[j]] <- data.frame(obs = lep_narm$result[test_idx],
                               pred = predict(lglep_cv[[j]], 
                                              newdata = lep_narm, 
                                              type = "response")[test_idx])
  # compute AUC
  auc_cv[j] <- roc(obs ~ pred, data = pred_v_cv[[j]])$auc
}

meanAUC_v <- round(mean(auc_cv), 4)
```

```{r, include = FALSE}
lglep_cv <- NULL
for (i in (1 : num_fold)){
  train_idx <- setdiff(1 : nrow(lep_narm), folds[[i]])
  lglep_cv[[i]] <- glmer(result ~ gender + landuse + hhoccup + (1|location), 
                         family = "binomial"(link = "logit"), 
                         data = lep_narm, subset = train_idx)
}

# initialize vectors to store predictive values and AUC
pred_v_cv <- NULL
auc_cv <- numeric(num_fold)

# predict and compute AUC of each model 
for (j in (1 : num_fold)){
  # test set
  test_idx <- folds[[j]] 
  # model prediction
  pred_v_cv[[j]] <- data.frame(obs = lep_narm$result[test_idx],
                               pred = predict(lglep_cv[[j]], 
                                              newdata = lep_narm, 
                                              type = "response",
                                              allow.new.levels = T)[test_idx])
  # compute AUC
  auc_cv[j] <- roc(obs ~ pred, data = pred_v_cv[[j]])$auc
}

meanAUC_l <- round(mean(auc_cv), 4)
```

```{r, include = FALSE}
lglep_cv <- NULL
for (i in (1 : num_fold)){
  train_idx <- setdiff(1 : nrow(lep_narm), folds[[i]])
  lglep_cv[[i]] <- glm(result ~ gender + landuse + hhoccup, 
                       family = "binomial"(link = "logit"), 
                       data = lep_narm, subset = train_idx)
}

# initialize vectors to store predictive values and AUC
pred_v_cv <- NULL
auc_cv <- numeric(num_fold)

# predict and compute AUC of each model 
for (j in (1 : num_fold)){
  # test set
  test_idx <- folds[[j]] 
  # model prediction
  pred_v_cv[[j]] <- data.frame(obs = lep_narm$result[test_idx],
                               pred = predict(lglep_cv[[j]], 
                                              newdata = lep_narm, 
                                              type = "response")[test_idx])
  # compute AUC
  auc_cv[j] <- roc(obs ~ pred, data = pred_v_cv[[j]])$auc
}

meanAUC_glm <- round(mean(auc_cv), 4)
```

```{r}
data.frame(model = c("glmer_v_1", "glmer_l","glm_selected"), 
           meanAUC = c(meanAUC_v, meanAUC_l, meanAUC_glm))
```

